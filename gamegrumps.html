<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Game Grumps Picker</title>

    <!-- Apple touch icons for iOS home screen -->
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-512.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-512.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="icons/icon-192.png" />

    <!-- iOS PWA settings -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <!-- Theme color for browsers -->
    <meta name="theme-color" content="#EDAC6E" />

    <style>
      /* Fonts */
      @font-face {
        font-family: "BD Cartoon Shout";
        src: url("./fonts/bd-cartoon-shout.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }
      @font-face {
        font-family: "Barthowheel";
        src: url("./fonts/Barthowheel.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      /* Preload for performance */
      @import url("./fonts/Barthowheel.ttf");
      @import url("./fonts/bd-cartoon-shout.ttf");

      /* Base styles */
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 1rem;
        background-color: #f29f46;
        color: black;
        min-height: 100vh;
        box-sizing: border-box;
      }
      *,
      *::before,
      *::after {
        box-sizing: inherit;
      }
      h1 {
        font-family: "BD Cartoon Shout", Arial, sans-serif;
        color: white;
        text-shadow: 2px 2px 0 #7190e3, -2px 2px 0 #7190e3, 2px -2px 0 #7190e3,
          -2px -2px 0 #7190e3;
        font-size: 3rem;
        margin: 0.3rem 0 1rem 0;
        text-align: center;
      }
      h2,
      #favoritesHeader {
        font-family: "BD Cartoon Shout", Arial, sans-serif;
        color: white;
        text-shadow: 2px 2px 0 #7190e3, -2px 2px 0 #7190e3, 2px -2px 0 #7190e3,
          -2px -2px 0 #7190e3;
        text-align: center;
      }
      #favoritesHeader {
        font-size: 2rem;
        margin: 2rem 0 0.5rem 0;
      }

      #favoritesInstructions {
        text-align: center;
        color: #666;
        font-style: italic;
        margin: 0 0 1rem 0;
        font-size: 0.9rem;
      }

      /* Corner images */
      .corner-images {
        position: relative;
        max-width: 900px;
        margin: 0 auto 0.5rem auto;
        height: 110px;
      }
      #hubButton {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #7190e3;
        border: 2px solid #9be1fa;
        border-radius: 8px;
        padding: 0.4rem 0.8rem;
        font-size: 1rem;
        color: black;
        font-weight: bold;
        font-family: "Barthowheel", Arial, sans-serif;
        cursor: pointer;
        transition: background-color 0.3s ease, border-color 0.3s ease;
        z-index: 15;
        text-decoration: none;
        display: inline-block;
      }
      #hubButton:hover {
        background-color: #5677cc;
        border-color: #7ec8f5;
      }
      #danCorner,
      #arinCorner {
        position: absolute;
        top: 0;
        width: 110px;
        height: 110px;
        background: none;
        border: none;
        padding: 0;
        z-index: 10;
      }
      #danCorner {
        left: 0;
      }
      #arinCorner {
        right: 0;
      }
      #danCorner img,
      #arinCorner img {
        width: 110px;
        height: 110px;
        object-fit: contain;
        display: block;
        border: none;
        background: none;
      }

      /* Main container */
      .container {
        max-width: 900px;
        margin: 0 auto;
        padding-top: 0.5rem;
      }

      /* Filters dropdown */
      #showFilter,
      #eraFilter {
        font-size: 1.1rem;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        border: 2px solid #9be1fa;
        font-family: Arial, sans-serif;
        min-width: 150px;
        margin: 0.5rem;
        text-align: center;
      }
      select#showFilter,
      select#eraFilter {
        font-family: "Barthowheel", Arial, sans-serif !important;
      }

      /* Add spacing between filters */
      #eraFilter {
        margin-bottom: 1rem;
      }

      /* Label + video title font */
      #filters label,
      label[for="showFilter"],
      label[for="eraFilter"],
      #videoTitle {
        font-family: "Barthowheel", Arial, sans-serif;
        font-weight: normal;
        line-height: 1.2;
      }

      /* Buttons */
      button {
        cursor: pointer;
        background-color: #7190e3;
        border: 2px solid #9be1fa;
        border-radius: 8px;
        padding: 0.6rem 1.2rem;
        font-size: 1.3rem;
        color: black;
        font-weight: bold;
        font-family: Arial, sans-serif;
        transition: background-color 0.3s ease, border-color 0.3s ease;
        min-width: 140px;
      }
      button:hover:not(:disabled) {
        background-color: #5677cc;
        border-color: #7ec8f5;
      }
      button:disabled {
        background-color: #555;
        border-color: #444;
        cursor: not-allowed;
        color: #ccc;
      }
      button#pickRandom {
        font-family: "Barthowheel", Arial, sans-serif !important;
        display: block;
        margin: 1rem auto; /* center button */
      }
      button#getVideoBtn,
      button#favBtn {
        font-family: "Barthowheel", Arial, sans-serif;
        font-size: 1.4rem;
      }

      /* Favorite button inside video section */
      .favorite-btn,
      #favBtn {
        display: block;
        margin: 1rem auto 2rem auto;
        max-width: 180px;
        text-align: center;
        padding: 0.6rem 1.2rem;
        font-size: 1.4rem;
      }

      /* Center dynamically injected video content */
      #playerContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #playerContainer iframe {
        margin-bottom: 0.5rem;
      }
      #playerContainer #videoTitle {
        margin-bottom: 0.5rem;
      }
      #playerContainer #favBtn {
        margin: 0.5rem auto 1.5rem auto;
      }

      /* Spinner */
      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #edac6e;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
        display: none;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Notice styling */
      .notice {
        font-size: 14px;
        color: black; /* changed from orange */
        margin-top: 10px;
        display: flex;
        justify-content: center; /* center under spinner */
        text-align: center;
      }

      /* Hide notice if videos appear */
      #playerContainer:not(:empty) + .notice,
      #favoritesContainer:not(:empty) + .notice {
        display: none;
      }

      /* Video Player Styles */
      #playerContainer iframe {
        display: block;
        width: 90vw;
        height: 50vw;
        max-width: 800px;
        max-height: 450px;
        border-radius: 8px;
        border: 3px solid #9be1fa;
        background: black;
      }

      /* make sure the injected video title uses Barthowheel */
      #videoTitle {
        font-family: "Barthowheel", Arial, sans-serif;
        font-size: 1.1rem;
        font-weight: bold;
        color: black;
        margin-top: 0.5rem;
        text-align: center;
      }

      /* Favorites styling - Tier List Layout */
      #favoritesContainer {
        margin-top: 20px;
        width: 100%;
        max-width: 1200px;
        margin-left: auto;
        margin-right: auto;
      }

      #tierListBackground {
        position: relative;
        height: 110%;
        width: 100%;
        background: white;
        border-radius: 8px;
        border: none;
        overflow: visible;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      #tierListImage {
        width: 100%;
        height: 110%;
        display: block;
        pointer-events: none;
      }

      #draggableArea {
        position: absolute;
        top: -10px;
        left: 0;
        width: 110%;
        height: 120%;
        pointer-events: auto;
      }

      .favVideo {
        position: absolute;
        cursor: grab;
        user-select: none;
        pointer-events: auto;
        z-index: 100;
        transition: transform 0.1s ease, box-shadow 0.1s ease;
        border-radius: 4px;
        border: none;
        margin-top: 0.25rem; /* space below remove button */
      }

      .favVideo img {
        width: 60px;
        height: 45px;
        border-radius: 4px;
        border: none;
        background: white;
        display: block;
        transition: border-color 0.2s ease;
      }

      .favVideo:hover img {
        border-color: transparent;
      }

      .favVideo .remove-fav-btn {
        position: absolute;
        bottom: -6px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #d33;
        border: none;
        padding: 0;
        border-radius: 50%;
        color: white;
        font-size: 0.7rem;
        cursor: pointer;
        width: 18px;
        height: 18px;
        display: none;
        z-index: 11;
        transition: background-color 0.2s ease;
        line-height: 18px;
        text-align: center;
      }

      .favVideo .remove-fav-btn:hover {
        background-color: #b22;
      }

      /* Empty state */
      #draggableArea:empty::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #666;
        font-style: italic;
        pointer-events: none;
      }

      /* Mobile touch improvements */
      @media (max-width: 720px) {
        .favVideo img {
          width: 45px;
          height: 33.75px;
        }

        .favVideo .remove-fav-btn {
          width: 14px;
          height: 14px;
          font-size: 0.5rem;
          line-height: 14px;
        }

        .favVideo:hover {
          transform: none;
        }
      }

      /* Animations */
      .pulse {
        animation: pulseAnim 0.8s ease forwards;
      }
      @keyframes pulseAnim {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Center filters + buttons */
      .controls {
        display: flex;
        flex-direction: column; /* stack vertically */
        align-items: center; /* center horizontally */
        justify-content: center; /* center vertically if container has height */
        gap: 1rem; /* spacing between filters and buttons */
        margin: 1rem 0;
        width: 100%;
      }

      /* Responsive tweaks */
      @media (max-width: 720px) {
        #playerContainer iframe {
          width: 95vw;
          height: 53vw;
        }
        #playerContainer #favBtn {
          max-width: 90vw;
          font-size: 1.2rem;
          padding: 0.5rem 1rem;
        }
        button {
          width: 90vw;
          max-width: 350px;
          font-size: 1.2rem;
        }
        /* Tier list responsive adjustments */
        #favoritesContainer {
          max-width: 95vw;
        }

        /* Center the label + dropdown on mobile */
        #filters {
          display: flex;
          flex-direction: column;
          align-items: center;
          text-align: center;
          margin-bottom: 0.5rem;
        }
        #filters label {
          margin-bottom: 0.2rem;
        }
        #showFilter,
        #eraFilter {
          width: 90vw;
          max-width: 350px;
        }
      }

      @media (max-width: 400px) {
        #playerContainer iframe {
          width: 95vw;
          height: 53vw;
        }
        #playerContainer #favBtn {
          max-width: 95vw;
          font-size: 1.1rem;
          padding: 0.4rem 0.8rem;
        }
        button {
          width: 95vw;
          font-size: 1.1rem;
          padding: 0.5rem 0.8rem;
        }
        /* Tier list responsive adjustments for small screens */
        #favoritesContainer {
          max-width: 98vw;
        }
        #showFilter,
        #eraFilter {
          width: 95vw;
        }
      }
    </style>
  </head>
  <body>
    <!-- Hub Button -->
    <a href="index.html" id="hubButton">← Hub</a>

    <!-- Corner Images -->
    <div class="corner-images">
      <button id="danCorner"><img src="icons/danny.webp" alt="Danny" /></button>
      <button id="arinCorner"><img src="icons/arin.png" alt="Arin" /></button>
    </div>

    <div class="container">
      <!-- Title -->
      <h1>Random Grumps</h1>

      <!-- Controls (filters + buttons) -->
      <div class="controls">
        <!-- Filters -->
        <div id="filters">
          <label for="eraFilter">Select Era:</label>
          <select id="eraFilter">
            <option value="">-- Select Era --</option>
            <option value="jon">Jon Era</option>
            <option value="dan">Dan Era</option>
          </select>

          <label for="showFilter">Select Show:</label>
          <select id="showFilter">
            <option value="">-- Select Show --</option>
          </select>
        </div>

        <!-- Buttons -->
        <div id="buttons">
          <button id="pickRandom">Pick Random Video</button>
        </div>
      </div>

      <!-- Spinner / Notice -->
      <div class="spinner" id="spinner"></div>
      <div class="notice" id="notice">
        Refreshing videos in the background...
      </div>

      <!-- Video Player -->
      <div id="playerContainer">
        <!-- Video iframe and title will be injected here -->
      </div>

      <!-- Favorites Section -->
      <h2 id="favoritesHeader">Favorites</h2>
      <p id="favoritesInstructions">
        Click thumbnails to play videos, drag to arrange your tier list!
      </p>
      <div id="favoritesContainer">
        <div id="tierListBackground">
          <img
            src="icons/tierlisttemplate.png"
            alt="Tier List Template"
            id="tierListImage"
          />
          <div id="draggableArea"></div>
        </div>
      </div>
    </div>

    <script>
      const apiKey = "AIzaSyDI2vTti8GNhb-W4z3MotLKGbinpRFU3qU";
      const channelUploadsId = "UCXq2nALoSbxLMehAvYTxt_A";

      const shows = [
        { id: "UU9CuvdOVfMPvKCiwdGKL3cQ", title: "Game Grumps" },
        { id: "PLPQSL8Iv1BRryWY9HOpDXsT5QhjbqgFIl", title: "Steam Train" },
        { id: "PLjXSjjpvIcpzCA8bqM45q-1IK_RDsTuJF", title: "Grumpcade" },
        { id: null, title: "The Grumps", channel: channelUploadsId },
        { id: "PLRQGRBgN_EnrsxaVTQJKIao6lDAJyYOw-", title: "Game Grumps Vs" },
        { id: "PLRQGRBgN_Enq32ulNww6QJxdSp0cygD6m", title: "Guest Grumps" },
        { id: "PLRQGRBgN_EnqqwNutiWwAj8tZhMFIJ1rx", title: "Jingle Grumps" },
        { id: "PLRQGRBgN_EnpND5AJknSiwwP9OKMYx4RP", title: "Ghoul Grumps" },
        { id: "PLRQGRBgN_Enoeu_3aRq4OsBRRMHQbJPRc", title: "Game Show Grumps" },
        { id: "PLC4E9F4F6136EF251", title: "Game Grumps Animated" },
      ];

      const showSelect = document.getElementById("showFilter");
      const eraSelect = document.getElementById("eraFilter");
      const spinner = document.getElementById("spinner");
      const notice = document.getElementById("notice");
      const playerContainer = document.getElementById("playerContainer");
      const favoritesContainer = document.getElementById("favoritesContainer");

      let db;
      const DB_NAME = "gameGrumpsDB";
      const STORE_VIDEOS = "videos";
      const STORE_FAVORITES = "favorites";
      const STORE_FAVORITE_POSITIONS = "favoritePositions";

      // Populate show dropdown
      shows.forEach((show) => {
        const opt = document.createElement("option");
        opt.value = show.id || show.channel;
        opt.textContent = show.title;
        showSelect.appendChild(opt);
      });

      // Default to Game Grumps
      showSelect.value = "UU9CuvdOVfMPvKCiwdGKL3cQ";

      // Default to no era filter (show all videos)
      eraSelect.value = "";

      // IndexedDB setup
      const request = indexedDB.open(DB_NAME, 2);
      request.onupgradeneeded = (e) => {
        db = e.target.result;
        if (!db.objectStoreNames.contains(STORE_VIDEOS))
          db.createObjectStore(STORE_VIDEOS, { keyPath: "title" });
        if (!db.objectStoreNames.contains(STORE_FAVORITES))
          db.createObjectStore(STORE_FAVORITES, { keyPath: "videoId" });
        if (!db.objectStoreNames.contains(STORE_FAVORITE_POSITIONS))
          db.createObjectStore(STORE_FAVORITE_POSITIONS, {
            keyPath: "videoId",
          });
      };

      request.onsuccess = async (e) => {
        db = e.target.result;

        // Initialize with retry logic
        await initializeApp();
      };

      async function initializeApp() {
        try {
          // Wait for DOM to be ready
          if (document.readyState === "loading") {
            await new Promise((resolve) => {
              document.addEventListener("DOMContentLoaded", resolve);
            });
          }

          // Additional small delay to ensure all elements are ready
          await new Promise((resolve) => setTimeout(resolve, 100));

          await loadFavorites();
          fetchAllShows(); // fetch everything on load
        } catch (error) {
          console.error("Error initializing app:", error);
          // Retry after a delay
          setTimeout(initializeApp, 500);
        }
      }
      request.onerror = (e) => console.error("IndexedDB error", e);

      // ---------- FAVORITES ----------
      let favorites = [];

      async function saveFavorite(video) {
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_FAVORITES, "readwrite");
          tx.objectStore(STORE_FAVORITES).put(video);
          tx.oncomplete = () => {
            loadFavorites().then(resolve).catch(reject);
          };
          tx.onerror = () => reject(tx.error);
        });
      }

      async function removeFavorite(videoId) {
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_FAVORITES, "readwrite");
          tx.objectStore(STORE_FAVORITES).delete(videoId);

          // Also remove position data (with error handling)
          try {
            const txPos = db.transaction(STORE_FAVORITE_POSITIONS, "readwrite");
            txPos.objectStore(STORE_FAVORITE_POSITIONS).delete(videoId);
          } catch (error) {
            console.warn("Position store not available yet:", error);
          }

          tx.oncomplete = () => {
            loadFavorites().then(resolve).catch(reject);
          };
          tx.onerror = () => reject(tx.error);
        });
      }

      async function saveFavoritePosition(videoId, x, y) {
        try {
          const tx = db.transaction(STORE_FAVORITE_POSITIONS, "readwrite");
          tx.objectStore(STORE_FAVORITE_POSITIONS).put({ videoId, x, y });
        } catch (error) {
          console.warn("Position store not available yet:", error);
        }
      }

      async function getFavoritePositions() {
        return new Promise((resolve) => {
          try {
            const tx = db.transaction(STORE_FAVORITE_POSITIONS, "readonly");
            const req = tx.objectStore(STORE_FAVORITE_POSITIONS).getAll();
            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => {
              console.warn("Position store not available yet");
              resolve([]);
            };
          } catch (error) {
            console.warn("Position store not available yet:", error);
            resolve([]);
          }
        });
      }

      function getAllFavorites() {
        return new Promise((resolve) => {
          try {
            const tx = db.transaction(STORE_FAVORITES, "readonly");
            const req = tx.objectStore(STORE_FAVORITES).getAll();
            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => {
              console.error("Error getting favorites from database");
              resolve([]);
            };
          } catch (error) {
            console.error("Error in getAllFavorites:", error);
            resolve([]);
          }
        });
      }

      async function loadFavorites() {
        try {
          favorites = await getAllFavorites();
          await renderFavorites();
        } catch (error) {
          console.error("Error loading favorites:", error);
        }
      }

      async function renderFavorites() {
        try {
          const draggableArea = document.getElementById("draggableArea");
          if (!draggableArea) {
            console.error("Draggable area not found");
            return;
          }

          draggableArea.innerHTML = "";

          // Small delay to ensure the area is properly loaded
          await new Promise((resolve) => setTimeout(resolve, 50));

          // Load cached positions
          const positions = await getFavoritePositions();
          const positionMap = {};
          positions.forEach((pos) => {
            positionMap[pos.videoId] = { x: pos.x, y: pos.y };
          });

          favorites.forEach((video, index) => {
            const div = document.createElement("div");
            div.className = "favVideo";
            div.dataset.videoId = video.videoId;

            // Use cached position or default grid position
            if (positionMap[video.videoId]) {
              div.style.left = `${positionMap[video.videoId].x}px`;
              div.style.top = `${positionMap[video.videoId].y}px`;
            } else {
              // Always position new favorites in the top left
              div.style.left = `20px`;
              div.style.top = `20px`;
            }

            div.innerHTML = `
              <img src="${video.thumbnail}" alt="${video.title}" draggable="false" />
              <button class="remove-fav-btn">&times;</button>
            `;

            // Remove button
            div.querySelector(".remove-fav-btn").onclick = async (e) => {
              e.stopPropagation();
              await removeFavorite(video.videoId);
            };

            // Drag and drop functionality with click handling
            makeDraggable(div, video);

            draggableArea.appendChild(div);
          });
        } catch (error) {
          console.error("Error rendering favorites:", error);
        }
      }

      // ---------- DRAG AND DROP FUNCTIONALITY ----------
      function makeDraggable(element, video) {
        let isDragging = false;
        let startX, startY, initialX, initialY;
        let clickTimeout;
        let hasMoved = false;

        // Mouse events for desktop
        element.addEventListener("mousedown", startDrag);
        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", endDrag);

        // Touch events for mobile
        element.addEventListener("touchstart", startDragTouch, {
          passive: false,
        });
        document.addEventListener("touchmove", dragTouch, { passive: false });
        document.addEventListener("touchend", endDragTouch);

        // Click to play video
        element.querySelector("img").onclick = (e) => {
          if (!hasMoved) {
            // Convert favorite object to the format expected by showVideo
            const videoForPlayback = {
              snippet: {
                resourceId: { videoId: video.videoId },
                title: video.title,
                thumbnails: { default: { url: video.thumbnail } },
              },
            };
            showVideo(videoForPlayback);
          }
        };

        function startDrag(e) {
          e.preventDefault();
          hasMoved = false;

          // Small delay to distinguish between click and drag
          clickTimeout = setTimeout(() => {
            isDragging = true;
            element.classList.add("dragging");
          }, 150);

          const rect = element.getBoundingClientRect();
          const containerRect = document
            .getElementById("draggableArea")
            .getBoundingClientRect();

          startX = e.clientX - rect.left;
          startY = e.clientY - rect.top;
          initialX = rect.left - containerRect.left;
          initialY = rect.top - containerRect.top;
        }

        function startDragTouch(e) {
          e.preventDefault();
          hasMoved = false;

          // Small delay to distinguish between tap and drag
          clickTimeout = setTimeout(() => {
            isDragging = true;
            element.classList.add("dragging");
          }, 150);

          const rect = element.getBoundingClientRect();
          const containerRect = document
            .getElementById("draggableArea")
            .getBoundingClientRect();
          const touch = e.touches[0];

          startX = touch.clientX - rect.left;
          startY = touch.clientY - rect.top;
          initialX = rect.left - containerRect.left;
          initialY = rect.top - containerRect.top;
        }

        function drag(e) {
          if (!isDragging) return;
          e.preventDefault();
          hasMoved = true;
          clearTimeout(clickTimeout);

          const containerRect = document
            .getElementById("draggableArea")
            .getBoundingClientRect();
          const newX = e.clientX - containerRect.left - startX;
          const newY = e.clientY - containerRect.top - startY;

          // Constrain to container bounds
          const maxX = containerRect.width - element.offsetWidth;
          const maxY = containerRect.height - element.offsetHeight;

          element.style.left = Math.max(0, Math.min(newX, maxX)) + "px";
          element.style.top = Math.max(0, Math.min(newY, maxY)) + "px";
        }

        function dragTouch(e) {
          if (!isDragging) return;
          e.preventDefault();
          hasMoved = true;
          clearTimeout(clickTimeout);

          const containerRect = document
            .getElementById("draggableArea")
            .getBoundingClientRect();
          const touch = e.touches[0];
          const newX = touch.clientX - containerRect.left - startX;
          const newY = touch.clientY - containerRect.top - startY;

          // Constrain to container bounds
          const maxX = containerRect.width - element.offsetWidth;
          const maxY = containerRect.height - element.offsetHeight;

          element.style.left = Math.max(0, Math.min(newX, maxX)) + "px";
          element.style.top = Math.max(0, Math.min(newY, maxY)) + "px";
        }

        function endDrag() {
          clearTimeout(clickTimeout);
          if (isDragging) {
            isDragging = false;
            element.classList.remove("dragging");

            // Save the new position
            const x = parseInt(element.style.left);
            const y = parseInt(element.style.top);
            saveFavoritePosition(video.videoId, x, y);
          }
        }

        function endDragTouch(e) {
          clearTimeout(clickTimeout);
          if (isDragging) {
            isDragging = false;
            element.classList.remove("dragging");

            // Save the new position
            const x = parseInt(element.style.left);
            const y = parseInt(element.style.top);
            saveFavoritePosition(video.videoId, x, y);
          }
        }
      }

      // ---------- VIDEO FETCH ----------
      const cache = {};

      async function fetchVideosFromAPI(show) {
        let videos = [];
        let nextPageToken = "";
        let firstLoad = true;

        notice.textContent = `Loading "${show.title}" videos…`;
        notice.style.display = "block";

        do {
          let url;
          if (show.id) {
            url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${show.id}&key=${apiKey}&pageToken=${nextPageToken}`;
          } else {
            url = `https://www.googleapis.com/youtube/v3/search?key=${apiKey}&channelId=${show.channel}&part=snippet&order=date&maxResults=50&type=video&pageToken=${nextPageToken}`;
          }

          const res = await fetch(url);
          const data = await res.json();
          if (data.error) {
            console.warn(data.error.message);
            notice.textContent = `Error fetching videos: ${data.error.message}`;
            break;
          }

          videos = videos.concat(
            data.items.map((item) => ({
              snippet: {
                resourceId: show.id
                  ? item.snippet.resourceId
                  : { videoId: item.id.videoId },
                title: item.snippet.title,
                thumbnails: item.snippet.thumbnails,
                publishedAt: item.snippet.publishedAt,
              },
            }))
          );

          nextPageToken = data.nextPageToken || "";

          if (!firstLoad && nextPageToken) {
            notice.textContent = `Fetching more "${show.title}" videos…`;
          }
          firstLoad = false;
        } while (nextPageToken);

        // Store in IndexedDB
        const tx = db.transaction(STORE_VIDEOS, "readwrite");
        tx.objectStore(STORE_VIDEOS).put({ title: show.title, videos });

        cache[show.title] = videos;

        return videos;
      }

      // ---------- FETCH ALL SHOWS ON LOAD ----------
      async function fetchAllShows() {
        spinner.style.display = "block";
        notice.textContent = "Loading all videos… please wait.";
        notice.style.display = "block";

        for (const show of shows) {
          // Check IndexedDB first
          const tx = db.transaction(STORE_VIDEOS, "readonly");
          const stored = await new Promise((resolve) => {
            const req = tx.objectStore(STORE_VIDEOS).get(show.title);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => resolve(null);
          });

          // Check if stored data has publishedAt field
          const hasPublishedAt =
            stored?.videos?.length > 0 &&
            stored.videos[0]?.snippet?.publishedAt;

          if (stored?.videos?.length && hasPublishedAt) {
            cache[show.title] = stored.videos;
            continue;
          }

          // Fetch from API if not cached or missing publishedAt
          await fetchVideosFromAPI(show);
        }

        spinner.style.display = "none";
        notice.textContent = "All videos loaded!";
        setTimeout(() => (notice.style.display = "none"), 2000);
      }

      // ---------- GET VIDEOS FROM CACHE ----------
      async function fetchVideos(show) {
        return cache[show.title] || [];
      }

      // ---------- ERA FILTERING ----------
      function filterVideosByEra(videos, era) {
        if (!era) return videos;

        const jonEraEndDate = new Date("2013-06-25T00:00:00Z");

        return videos.filter((video) => {
          // Handle cases where publishedAt might not exist in cached data
          if (!video.snippet.publishedAt) {
            console.warn(
              "Video missing publishedAt field:",
              video.snippet.title
            );
            return true; // Include videos without date info
          }

          const publishedAt = new Date(video.snippet.publishedAt);

          if (era === "jon") {
            return publishedAt < jonEraEndDate;
          } else if (era === "dan") {
            return publishedAt >= jonEraEndDate;
          }

          return true;
        });
      }

      // ---------- VIDEO DISPLAY ----------
      function showVideo(video) {
        const videoId = video.snippet.resourceId.videoId;
        const title = video.snippet.title || "Video";
        const thumbnail = video.snippet.thumbnails?.default?.url || "";

        function updateFavButton() {
          const favBtn = document.getElementById("favBtn");
          const inFav = favorites.some((f) => f.videoId === videoId);
          favBtn.textContent = inFav
            ? "Remove from Favorites"
            : "Add to Favorites";
        }

        async function toggleFavorite() {
          const inFav = favorites.some((f) => f.videoId === videoId);
          const favVideo = { videoId, title, thumbnail };

          if (inFav) {
            await removeFavorite(videoId);
          } else {
            await saveFavorite(favVideo);
          }

          // Update button state after the async operation completes
          updateFavButton();
        }

        playerContainer.innerHTML = `
          <iframe src="https://www.youtube.com/embed/${videoId}" allowfullscreen></iframe>
          <div id="videoTitle">${title}</div>
          <button id="favBtn">Add to Favorites</button>
        `;

        updateFavButton();
        document.getElementById("favBtn").onclick = async () =>
          await toggleFavorite();
      }

      // ---------- RANDOM PICKER ----------
      document
        .getElementById("pickRandom")
        .addEventListener("click", async () => {
          const selectedValue = showSelect.value || "UU9CuvdOVfMPvKCiwdGKL3cQ";
          const selectedShow = shows.find(
            (s) => s.id === selectedValue || s.channel === selectedValue
          );
          const selectedEra = eraSelect.value;

          const videos = await fetchVideos(selectedShow);
          if (!videos.length) {
            notice.textContent = "No videos found.";
            return;
          }

          // Apply era filter
          const filteredVideos = filterVideosByEra(videos, selectedEra);

          if (!filteredVideos.length) {
            const eraText = selectedEra
              ? ` in ${selectedEra === "jon" ? "Jon" : "Dan"} Era`
              : "";
            notice.textContent = `No videos found for ${selectedShow.title}${eraText}.`;
            return;
          }

          const randomVideo =
            filteredVideos[Math.floor(Math.random() * filteredVideos.length)];
          showVideo(randomVideo);

          // Show filter status
          const eraText = selectedEra
            ? ` (${selectedEra === "jon" ? "Jon" : "Dan"} Era)`
            : "";
          notice.textContent = `Showing: ${selectedShow.title}${eraText} - ${filteredVideos.length} videos available`;
          setTimeout(() => (notice.style.display = "none"), 3000);
        });
    </script>
  </body>
</html>
